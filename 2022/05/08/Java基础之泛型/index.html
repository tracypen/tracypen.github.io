<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favor16.ico?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favor32.ico?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="泛型概述以及泛型类        泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入； 泛型的核心: 告诉编译器想使用什么类型，然后编译器帮你处理一切；">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础之泛型">
<meta property="og:url" content="https://hawawa.gitee.io/2022/05/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="peng.hao">
<meta property="og:description" content="泛型概述以及泛型类        泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入； 泛型的核心: 告诉编译器想使用什么类型，然后编译器帮你处理一切；">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-08T13:15:07.000Z">
<meta property="article:modified_time" content="2022-05-19T08:22:43.556Z">
<meta property="article:author" content="hao peng">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary"><title>Java基础之泛型 | peng.hao</title><link ref="canonical" href="https://hawawa.gitee.io/2022/05/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">peng.hao</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Java基础之泛型</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-08</span></span></div></header><div class="post-body">
        <h3 id="泛型概述以及泛型类"   >
          <a href="#泛型概述以及泛型类" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型概述以及泛型类" class="headerlink" title="泛型概述以及泛型类"></a>泛型概述以及泛型类</h3>
      <ul>
<li>泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入；</li>
<li>泛型的核心: 告诉编译器想使用什么类型，然后编译器帮你处理一切；</li>
</ul>
<span id="more"></span>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class GenericClass &#123;</span><br><span class="line"></span><br><span class="line">    private static class Pair&lt;U,V&gt;&#123;</span><br><span class="line">        private U first;</span><br><span class="line">        private V second;</span><br><span class="line"></span><br><span class="line">        public Pair(U first, V second) &#123;</span><br><span class="line">            this.first = first;</span><br><span class="line">            this.second = second;</span><br><span class="line">        &#125;</span><br><span class="line">        public U getFirst() &#123;</span><br><span class="line">            return first;</span><br><span class="line">        &#125;</span><br><span class="line">        public V getSecond() &#123;</span><br><span class="line">            return second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Pair&lt;String,Integer&gt;pair = new Pair&lt;&gt;(&quot;zhangsan&quot;, 23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>为什么Java不直接使用普通的Object类呢 ？</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GenericClass2 &#123;</span><br><span class="line"></span><br><span class="line">    private static class Pair&#123; //　Generic Class</span><br><span class="line">        private Object first;</span><br><span class="line">        private Object second;</span><br><span class="line"></span><br><span class="line">        public Pair(Object first, Object second) &#123;</span><br><span class="line">            this.first = first;</span><br><span class="line">            this.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getFirst() &#123;</span><br><span class="line">            return first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getSecond() &#123;</span><br><span class="line">            return second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Pair pair = new Pair(&quot;zhangsan&quot;, 23);</span><br><span class="line">        String name = (String) pair.getFirst();</span><br><span class="line">        Integer age = (Integer) pair.getSecond();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>其实是可以这样的，而且Java的内部就是这样实现的。</p>
</blockquote>
<ul>
<li>Java有Java编译器和Java虚拟机，编译器将Java源代码转换为.class文件，虚拟机加载并运行.class文件。</li>
<li>对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，就像上面的普通Pair类代码及其使用代码一样，将类型参数T擦除，替换为Object，插入必要的强制类型转换。Java虚拟机实际执行的时候，它是不知道泛型这回事的，它只知道普通的类及代码。</li>
<li>再次强调，Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数，比如Pair<Integer>，运行中只知道Pair，而不知道Integer。</li>
</ul>
<blockquote>
<p>那为什么还要使用泛型呢? 泛型有两个好处:</p>
</blockquote>
<ul>
<li>更好的安全性；</li>
<li>更高的可读性；
        <h3 id="泛型方法"   >
          <a href="#泛型方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3>
      </li>
<li>要定义泛型方法，只需要将泛型参数列表置于返回值前；</li>
<li>注意: 一个方法是不是泛型的, 和它所在的类是不是泛型没有任何关系；</li>
<li>泛型方法调用的时候，不需要指定类型参数的实际类型，Java编译器会推断出来；<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethod &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; int indexOf(T[] arr, T ele)&#123; // Generic Method</span><br><span class="line">        for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            if(arr[i].equals(ele))</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(indexOf(new Integer[]&#123;1, 3, 5, 7&#125;, 5));</span><br><span class="line">        System.out.println(indexOf(new String[]&#123;&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;&#125;, &quot;lisi&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
实际上泛型类和泛型方法没有联系:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//泛型类的泛型和泛型方法的泛型没有一点关系</span><br><span class="line">public class GenericClassMethod&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void testMethod(T t)&#123;</span><br><span class="line">        System.out.println(t.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T testMethod1(T t)&#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        GenericClassMethod&lt;String&gt;gcm = new GenericClassMethod&lt;&gt;();</span><br><span class="line">        gcm.testMethod(&quot;generic&quot;);</span><br><span class="line">        Integer res = gcm.testMethod1(new Integer(10));</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// java.lang.String</span><br><span class="line">// 10</span><br></pre></td></tr></table></div></figure>

        <h3 id="三、泛型接口"   >
          <a href="#三、泛型接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、泛型接口" class="headerlink" title="三、泛型接口"></a>三、泛型接口</h3>
      接口也可以是泛型的，例如，Java中的<code>Comparable</code>和<code>Comparator</code>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    public int compareTo(T o);</span><br><span class="line">&#125;</span><br><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="四、extends、-lt-、参数类型必须是给定的或者子类型"   >
          <a href="#四、extends、-lt-、参数类型必须是给定的或者子类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、extends、-lt-、参数类型必须是给定的或者子类型" class="headerlink" title="四、extends、&lt;=、参数类型必须是给定的或者子类型"></a>四、extends、&lt;=、参数类型必须是给定的或者子类型</h3>
      
        <h4 id="1、上界为某个具体类"   >
          <a href="#1、上界为某个具体类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、上界为某个具体类" class="headerlink" title="1、上界为某个具体类"></a>1、上界为某个具体类</h4>
      </li>
<li>可以使用extends来限定一个上界，此时参数类型必须是给定的类型或者其子类型；</li>
<li>比如定义一个NumberPair类，限定两个参数类型必须是Number或者子类型，这样限定之后，在子类中，first、second变量就可以当做Number进行处理了，比如调用Number类中的方法doubleValue()、intValue等；<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 示例代码，(省略了上面的Pair&lt;U,V&gt;类)</span><br><span class="line">public class GenericExtends &#123;</span><br><span class="line"></span><br><span class="line">    private static class NumberPair&lt;U extends Number, V extends Number&gt; extends Pair&lt;U, V&gt;&#123;</span><br><span class="line"></span><br><span class="line">        public NumberPair(U first, V second) &#123; // must realize (achieve)</span><br><span class="line">            super(first, second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public double getSum()&#123;</span><br><span class="line">            return getFirst().doubleValue() + getSecond().intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        NumberPair&lt;Double, Integer&gt;np = new NumberPair&lt;&gt;(3.3, 3); // &lt;U, V&gt;可以是 Number的子类，即 &lt;=</span><br><span class="line">        System.out.println(np.getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-上界为某个接口"   >
          <a href="#2-上界为某个接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-上界为某个接口" class="headerlink" title="2.上界为某个接口"></a>2.上界为某个接口</h4>
      在泛型方法中，一种常见的限定类型是必须实现Comparable接口:</li>
<li>下面的例子，要进行元素的比较，要求元素必须实现Comparable接口， 所以给类型参数设置了一个上边界Comparable 必须实现Comparable接口；</li>
<li>可以理解为： T是一种数据类型，必须实现Comparable,且必须可以与相同类型的元素进行比较；<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ublic class GenericExtends2 &#123;</span><br><span class="line"></span><br><span class="line">    // 要进行元素的比较，要求元素必须实现Comparable接口</span><br><span class="line">    // 所以给类型参数设置了一个上边界Comparable,T 必须实现Comparable接口</span><br><span class="line">    public static &lt;T extends Comparable&gt; T getMax(T[] arr)&#123;</span><br><span class="line">        T max = arr[0];</span><br><span class="line">        for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            if(arr[i].compareTo(max) &gt; 0)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不过上面这么写会有警告 因为Comparable是一个泛型接口，它也需要一个类型参数，所以下面的写法比较好</span><br><span class="line">    // 理解: T是一种数据类型，必须实现Comparable,且必须可以与相同类型的元素进行比较</span><br><span class="line">    public static &lt;T extends Comparable&lt;T&gt; &gt; T getMax2(T[] arr)&#123;</span><br><span class="line">        T max = arr[0];</span><br><span class="line">        for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            if(arr[i].compareTo(max) &gt; 0)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="3-上界为其他参数类型"   >
          <a href="#3-上界为其他参数类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-上界为其他参数类型" class="headerlink" title="3.上界为其他参数类型"></a>3.上界为其他参数类型</h4>
      </li>
<li>这里模仿ArrayList来创建一个类， 并想着实现其中的addAll()方法，但是如果不使用一个上界的话，会出现无法添加子类的情况，看下面的代码，Number的集合理应可以添加Integer类型的元素。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class GenericExtends3 &#123;</span><br><span class="line"></span><br><span class="line">    // seems like ArrayList</span><br><span class="line">    private static class DynamicArray&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">        private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">        private int size;</span><br><span class="line">        private Object[] data;</span><br><span class="line"></span><br><span class="line">        public DynamicArray() &#123;</span><br><span class="line">            this.data = new Object[DEFAULT_CAPACITY];</span><br><span class="line">        &#125;</span><br><span class="line">        private void ensureCapacity(int minCapacity)&#123;  // simulate ArrayList</span><br><span class="line">            int oldCapacity = data.length;</span><br><span class="line">            if(oldCapacity &gt;= minCapacity)</span><br><span class="line">                return;</span><br><span class="line">            int newCapacity = oldCapacity * 2;</span><br><span class="line">            if(newCapacity &lt; minCapacity) //如果扩展2倍还是小于minCapacity，就直接扩展成为minCapacity</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            data = Arrays.copyOf(data, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void add(E e)&#123;</span><br><span class="line">            ensureCapacity(size + 1);</span><br><span class="line">            data[size++] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E get(int index)&#123;</span><br><span class="line">            return (E)data[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int size()&#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public E set(int index, E e)&#123;</span><br><span class="line">            E oldValue = get(index);</span><br><span class="line">            data[index] = e;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void addAll(DynamicArray&lt;E&gt;arr)&#123;</span><br><span class="line">            for(int i = 0; i &lt; arr.size; i++)&#123;</span><br><span class="line">                add(arr.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DynamicArray&lt;Number&gt;numbers = new DynamicArray&lt;&gt;();</span><br><span class="line">        DynamicArray&lt;Integer&gt;ints = new DynamicArray&lt;&gt;();</span><br><span class="line">        ints.add(10);</span><br><span class="line">        ints.add(20);</span><br><span class="line">//        numbers.addAll(ints); // compile error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
那个需求感觉上是可以，但是通过反证法可以发现是行不通的，看下面代码以及解释:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt;numbers = new DynamicArray&lt;&gt;();</span><br><span class="line">numbers = ints; // 假设合法</span><br><span class="line">numbers.add(new Double(3.3)); // 那么这一样也可以，此时因为numbers和ints指向的同一个堆区空间，则ints中出现double类型值，显然不合理</span><br><span class="line"></span><br><span class="line">//再看一个例子</span><br><span class="line">List&lt;Object&gt;olist = null;</span><br><span class="line">List&lt;String&gt;slist = new ArrayList&lt;&gt;();</span><br><span class="line">olist = slist; // err</span><br><span class="line">//如果上述假设合理</span><br><span class="line">olist.add(111);</span><br><span class="line">//则slist中就会出现Integer类型的值，显然不合理</span><br></pre></td></tr></table></div></figure>
所以，可以使用上界类型将addAll方法改进如下:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//传入的是T类型，限定为是E类型或者E的子类类型</span><br><span class="line">public &lt;T extends E&gt;void addAll(DynamicArray&lt;T&gt;arr)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.size; i++)&#123;</span><br><span class="line">        add(arr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="五、通配符"   >
          <a href="#五、通配符" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、通配符" class="headerlink" title="五、通配符?"></a>五、通配符?</h3>
      
        <h4 id="1、有限定类型通配符的简单使用"   >
          <a href="#1、有限定类型通配符的简单使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、有限定类型通配符的简单使用" class="headerlink" title="1、有限定类型通配符的简单使用"></a>1、有限定类型通配符的简单使用</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void addAll(DynamicArray&lt;? extends E&gt;arr)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.size; i++)&#123;</span><br><span class="line">        add(arr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<code>&lt;? extends E&gt;</code>表示有限定通配符，匹配E或E的某个子类型，具体是什么子类型是未知的。 看一下<code>public &lt;T extends E&gt;void addAll(DynamicArray&lt;T&gt;arr)</code> 和<code>public void addAll(DynamicArray&lt;? extends E&gt;arr)</code>的区别:</li>
<li><code>&lt;T extends E&gt;</code>用于定义类型参数，它声明了一个类型参数T，可放在泛型类中类名的后面、泛型方法返回值前面；</li>
<li><code>&lt;? extends E&gt;</code>用于实例化类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的子类型；
        <h4 id="2、无限定类型通配符"   >
          <a href="#2、无限定类型通配符" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、无限定类型通配符" class="headerlink" title="2、无限定类型通配符"></a>2、无限定类型通配符</h4>
      简单使用: 第一种方式使用通配符，第二种方式使用类型参数，可以达到同样的目的:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//使用通配符  </span><br><span class="line">public static int indexOf(DynamicArray&lt;?&gt; arr, Object elm)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.size(); i++)&#123;</span><br><span class="line">        if(arr.get(i).equals(elm))</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用类型参数 type parameter</span><br><span class="line">public static &lt;T&gt; int indexOf2(DynamicArray&lt;T&gt; arr, Object elm)&#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.size(); i++)&#123;</span><br><span class="line">        if(arr.get(i).equals(elm))</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
但是通配符也有一些限制</li>
<li>1)、第一条限制: 只能读，不能写<br>比如 ，下面三行代码就会报错 :<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardCharacter &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ints = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;? extends Number&gt; numbers = ints; // 使用extends通配符指定上界</span><br><span class="line"></span><br><span class="line">        Integer a = 10;</span><br><span class="line">//        numbers.add(a); // err</span><br><span class="line">//        numbers.add(Object(a)); //err</span><br><span class="line">//        numbers.add(Number(a)); //err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>解释: ?表示类型安全无知，? extends Number表示是Number的某个子类型，但不知道具体子类型，如果允许写入，Java就无法确保类型安全性，所以干脆禁止；</li>
<li>这种限制关系是好的，但是这使得很多理应可以完成的操作可能会出现错误；<br>比如: 下面的代码中最后两行会报错，原因就是不能修改？通配符的值：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(ArrayList&lt;?&gt; arr, int i, int j)&#123;</span><br><span class="line">     Object tmp = arr.get(i);</span><br><span class="line">     arr.set(i, arr.get(j)); // can&#x27;t change the value</span><br><span class="line">     arr.set(j, tmp);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
再看一个例子：在方法传递参数的时候，不能往参数中添加元素:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class GenericExtends4 &#123;</span><br><span class="line"></span><br><span class="line">	private static class Fruit &#123;&#125;</span><br><span class="line">	private static class Apple extends Fruit&#123;&#125;</span><br><span class="line">	private static class Pear extends Fruit&#123;&#125;</span><br><span class="line">	private static class FuShiApple extends Apple&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Clazz&lt;T extends Fruit&gt;&#123;  //创建的类必须是Fruit的子类//为了自己类中使用这个类</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Clazz&lt;Fruit&gt;t = new Clazz&lt;&gt;();  // &lt;= 关系</span><br><span class="line">		Clazz&lt;Apple&gt;t2 = new Clazz&lt;&gt;();</span><br><span class="line">		Clazz&lt;Pear&gt;t3 = new Clazz&lt;&gt;();</span><br><span class="line">		Clazz&lt;FuShiApple&gt;t4= new Clazz&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		//调用方法</span><br><span class="line">		List&lt;? extends Fruit&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list1);</span><br><span class="line">		List&lt;Fruit&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list2);</span><br><span class="line">		List&lt;Apple&gt; list3 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list3);</span><br><span class="line">		List&lt;? extends Apple&gt; list4 = new ArrayList&lt;FuShiApple&gt;();  //存放Apple以及它的子类</span><br><span class="line">		add(list4);</span><br><span class="line">		List&lt;FuShiApple&gt; list5 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		//？为什么错误 : 因为 ? 等同于？ extends Object :不是&lt;= Fruit的 下面两个是一样的</span><br><span class="line">		List&lt;?&gt;list6 = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;? extends Object&gt;list7 = new ArrayList&lt;&gt;();</span><br><span class="line">		//add(list6); // err</span><br><span class="line">		//add(list7); // err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 为了保证向下兼容的一致性，不能添加元素</span><br><span class="line">	public static void add(List&lt;? extends Fruit&gt; list) &#123;</span><br><span class="line">		/** 不能往里面加这样的对象 不能用于添加数据</span><br><span class="line">		 list.add(new Fruit());</span><br><span class="line">		 list.add(new Apple());</span><br><span class="line">		 list.add(new Pear());</span><br><span class="line">		 */</span><br><span class="line">		list.add(null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>2)、第二条限制: 参数类型间的依赖关系<br>如果参数类型之间有依赖关系，也只能用类型参数，比如下面的例子:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// S和D要么相同，要么S是D的子类，否则类型不兼容，有编译错误</span><br><span class="line">public static &lt;D,S extends D&gt; void copy(ArrayList&lt;D&gt; dest, ArrayList&lt;S&gt; src)&#123;</span><br><span class="line">    for(int i=0; i&lt;src.size(); i++)</span><br><span class="line">        dest.add(src.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以使用通配符简化一下</span><br><span class="line">public static &lt;D&gt; void copy2(ArrayList&lt;D&gt; dest, ArrayList&lt;? extends D&gt; src)&#123;</span><br><span class="line">    for(int i=0; i&lt;src.size(); i++)</span><br><span class="line">        dest.add(src.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>3)、第三条限制: 如果返回值依赖于类型参数，也不能用通配符<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//不能使用通配符，只能用类型参数，因为要返回</span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt; &gt; T max(ArrayList&lt;T&gt; arr)&#123;</span><br><span class="line">    T max = arr.get(0);</span><br><span class="line">    for(int i = 1; i &lt; arr.size(); i++)&#123;</span><br><span class="line">        if(arr.get(i).compareTo(max)&gt;0)&#123;</span><br><span class="line">            max = arr.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
那么到底该用通配符还是类型参数呢?<blockquote>
<ul>
<li>通配符形式都可以用类型参数的形式来替代，通配符能做的，用类型参数都能做。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>通配符形式可以减少类型参数，形式上往往更为简单，可读性也更好，所以，能用通配符的就用通配符。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果类型参数之间有依赖关系，或者返回值依赖类型参数，或者需要写操作，则只能用类型参数。</li>
</ul>
</blockquote>
<p>通配符形式和类型参数往往配合使用，比如，上面的copy2方法，定义必要的类型参数，使用通配符表达依赖，并接受更广泛的数据类型。</p>

        <h3 id="六、super、-gt-、超类型通配符"   >
          <a href="#六、super、-gt-、超类型通配符" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、super、-gt-、超类型通配符" class="headerlink" title="六、super、&gt;=、超类型通配符"></a>六、super、&gt;=、超类型通配符</h3>
      <ul>
<li>简单的来说，super和extends刚好相反，匹配的是&gt;= E的类型；</li>
<li>相当于是规定了一个下界，可以匹配 &gt;=的类型；
        <h4 id="1、使用场景"   >
          <a href="#1、使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h4>
      看它的使用场景， 在DynamicArray中添加一个copyTo方法，功能是将当前对象容器中的数拷贝到传入的参数dest容器中:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//add current value to the dest collection</span><br><span class="line"> public void copyTo(DynamicArray&lt;E&gt;dest)&#123;</span><br><span class="line">     for(int i = 0; i &lt; dest.size(); i++)</span><br><span class="line">         dest.add(this.get(i));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
然后不使用super，看下面的代码，最后一行就会报错，但是将Integer数组拷贝到Number数组理应是可以的:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">      DynamicArray&lt;Integer&gt;ints = new DynamicArray&lt;&gt;();</span><br><span class="line">      ints.add(3);</span><br><span class="line">      ints.add(4);</span><br><span class="line"></span><br><span class="line">      DynamicArray&lt;Number&gt;nums = new DynamicArray&lt;&gt;();</span><br><span class="line">      ints.copyTo(nums);  // 将ints 中的元素拷贝到nums，本应该是可以的，但是如果没有? super E就不行</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
使用超类型通配符就可以解决上面的问题:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void copyTo(DynamicArray&lt;? super E&gt;dest)&#123;</span><br><span class="line">    for(int i = 0; i &lt; dest.size(); i++)</span><br><span class="line">        dest.add(this.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h4 id="2、没有-lt-T-super-E-gt-有"   >
          <a href="#2、没有-lt-T-super-E-gt-有" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、没有-lt-T-super-E-gt-有" class="headerlink" title="2、没有&lt; T super E&gt;(有)"></a>2、没有&lt; T super E&gt;(有<T extend E>)</h4>
      比较类型参数限定与超类型通配符，类型参数限定只有extends形式，没有super形式，比如前面的copyTo方法，它的通配符形式的声明为：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void copyTo(DynamicArray&lt;? super E&gt; dest)</span><br></pre></td></tr></table></div></figure>
如果类型参数限定支持super形式，则应该是：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T super E&gt; void copyTo(DynamicArray&lt;T&gt; dest)</span><br></pre></td></tr></table></div></figure>
但是，Java并不支持这种语法。对于有限定的通配符形式&lt;? extends E&gt;，可以用类型参数限定替代，但是对于类似上面的超类型通配符，则无法用类型参数替代。<br>再看和extends使用方法传递参数的对比: (在方法传递中可以添加自己和子类的数据，　区别于extends，extends都不可以添加)<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class GenericSuper2 &#123;</span><br><span class="line"></span><br><span class="line">    private static class Fruit &#123;&#125;</span><br><span class="line">    private static class Apple extends Fruit&#123;&#125;</span><br><span class="line">    private static class Pear extends Fruit&#123;&#125;</span><br><span class="line">    private static class FuShiApple extends Apple&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Clazz&lt;T extends Fruit&gt;&#123;  //创建的类必须是Fruit的子类//为了自己类中使用这个类</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Apple&gt;list1 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list1);</span><br><span class="line">		List&lt;Fruit&gt;list2 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list2);</span><br><span class="line">		List&lt;Object&gt;list3 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list3);</span><br><span class="line"></span><br><span class="line">		//？super的使用</span><br><span class="line">		List&lt;? super Apple&gt;list4 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list4);</span><br><span class="line">		List&lt;? super Apple&gt;list5 = new ArrayList&lt;&gt;();</span><br><span class="line">		add(list5);</span><br><span class="line">		</span><br><span class="line">		List&lt;FuShiApple&gt;list6 = new ArrayList&lt;&gt;();  // &lt; 的不行</span><br><span class="line">//		add(list6); // err</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//只要是Apple的祖先都可以调用这个方法 &gt;= </span><br><span class="line">	public static void add(List &lt;? super Apple&gt; list) &#123;  </span><br><span class="line">		/*** 不能用于添加父类对象的数据</span><br><span class="line">		 * list.add(new Fruit());</span><br><span class="line">		 */</span><br><span class="line">		//区别于extends, 可以添加自己和子类的数据</span><br><span class="line">		list.add(new Apple());</span><br><span class="line">		list.add(new FuShiApple());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="七、通配符extends、super比较"   >
          <a href="#七、通配符extends、super比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、通配符extends、super比较" class="headerlink" title="七、通配符extends、super比较"></a>七、通配符extends、super比较</h3>
      <p>通配符比较:</p>
<ul>
<li><p>共同点: 目的都是为了使方法接口更为灵活，可以接受更为广泛的类型。</p>
</li>
<li><? super E>用于灵活写入或比较，使得对象可以写入父类型的容器(>=)，使得父类型的比较方法可以应用于子类对象。</li>
<li><? extends E>用于灵活读取，使得方法可以读取E或E的任意子类型的容器对象。
Java容器类的实现中，有很多这种用法，比如，Collections中就有如下一些方法：
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</span><br></pre></td></tr></table></div></figure>
### 八、泛型擦除</li>
<li><p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p>
</li>
<li><p>通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方；<br>看下面代码：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class GenericWipe &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; slist = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ilist = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.println(slist.getClass() == ilist.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这段代码的输出结果是true。正如一开始说的，编译器会将T擦除，然后替换成为Object(并不完全正确)，在必要的时候进行强制类型转换。</p>
</li>
</ul>
<p>再看以下代码的输出结果:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GenericWipe&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public GenericWipe(T obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        GenericWipe&lt;String&gt;gw = new GenericWipe&lt;&gt;(&quot;wipe&quot;);</span><br><span class="line">        Class gwClass = gw.getClass();</span><br><span class="line">        System.out.println(gwClass.getName()); // 得到运行时的状态信息,运行时是真实的类型</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Field[] fs = gwClass.getDeclaredFields();  //得到在JVM中的类型 </span><br><span class="line">        for ( Field f:fs)</span><br><span class="line">            System.out.println(&quot;Field name &quot; + f.getName() + &quot; type:&quot; + f.getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaPrimary.Generic.GenericWipe</span><br><span class="line">--------------------------</span><br><span class="line">Field name obj type:java.lang.Object</span><br></pre></td></tr></table></div></figure>
<p>第一种类型是<code>Class</code> 的类型是 <code>GenericWipe</code>，并不是 <code>GenericWipe&lt;T&gt;</code> 这种形式，第二种类型是<code>Jvm</code>中的类型； 那是不是泛型类被类型擦除后，相应的类型就被替换成 <code>Object</code> 类型呢？这种说法不是完全正确的。</p>
<p>更改一下代码:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GenericWipe&lt;T extends String&gt; &#123;  // &lt;= String</span><br><span class="line"></span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public GenericWipe(T obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        GenericWipe&lt;String&gt;gw = new GenericWipe&lt;&gt;(&quot;wipe&quot;);</span><br><span class="line">        Class gwClass = gw.getClass();</span><br><span class="line">        System.out.println(gwClass.getName()); // 得到运行时的状态信息,运行时是真实的类型</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Field[] fs = gwClass.getDeclaredFields();  //得到在JVM中的类型</span><br><span class="line">        for ( Field f:fs)</span><br><span class="line">            System.out.println(&quot;Field name &quot; + f.getName() + &quot; type:&quot; + f.getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaPrimary.Generic.GenericWipe</span><br><span class="line">--------------------------</span><br><span class="line">Field name obj type:java.lang.String</span><br></pre></td></tr></table></div></figure>
<p>可以看到，第二个输出变成了String。所以结论如下:</p>
<ul>
<li>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如<T>则会被转译成普通的 Object 类型；</li>
<li>如果指定了上限如 <T extends String> 则类型参数就被替换成类型上限。<br>所以，在反射中，add() 这个方法对应的 Method 的签名应该是 Object.class。也就是说，如果你要在反射中找到 add 对应的 Method，你应该调用 getDeclaredMethod(“add”,Object.class) 否则程序会报错，提示没有这么一个方法，原因就是类型擦除的时候，T 被替换成 Object 类型了。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class GenericWipe&lt;T&gt; &#123;  // &lt;= String</span><br><span class="line">    // public class GenericWipe&lt;T extends String&gt; &#123;  // &lt;= String</span><br><span class="line">    private T obj;</span><br><span class="line"></span><br><span class="line">    public GenericWipe(T obj)&#123;</span><br><span class="line">        this.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(T obj)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        GenericWipe&lt;String&gt;gw = new GenericWipe&lt;&gt;(&quot;wipe&quot;);</span><br><span class="line">        Class gwClass = gw.getClass();</span><br><span class="line">        System.out.println(gwClass.getName()); // 得到运行时的状态信息,运行时是真实的类型</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------------&quot;);</span><br><span class="line">        Method[] methods = gwClass.getDeclaredMethods();</span><br><span class="line">        for ( Method m:methods )&#123;</span><br><span class="line">            System.out.println(&quot; method:&quot; + m.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<a href="%5Bhttps://blog.csdn.net/briblue/article/details/76736356#t11%5D(https://blog.csdn.net/briblue/article/details/76736356#t11)">更加详细的解释见这里</a>
        <h3 id="九、泛型注意事项"   >
          <a href="#九、泛型注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、泛型注意事项" class="headerlink" title="九、泛型注意事项"></a>九、泛型注意事项</h3>
      
        <h4 id="1、基本类型不能用于实例化类型参数，也就是泛型类或者泛型方法中，不接受-8-种基本数据类型。"   >
          <a href="#1、基本类型不能用于实例化类型参数，也就是泛型类或者泛型方法中，不接受-8-种基本数据类型。" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、基本类型不能用于实例化类型参数，也就是泛型类或者泛型方法中，不接受-8-种基本数据类型。" class="headerlink" title="1、基本类型不能用于实例化类型参数，也就是泛型类或者泛型方法中，不接受 8 种基本数据类型。"></a>1、基本类型不能用于实例化类型参数，也就是泛型类或者泛型方法中，不接受 8 种基本数据类型。</h4>
      比如:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; li = new ArrayList&lt;&gt;(); // err</span><br><span class="line">List&lt;boolean&gt; li = new ArrayList&lt;&gt;(); // err</span><br><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();  //ok</span><br><span class="line">List&lt;Boolean&gt; li1 = new ArrayList&lt;&gt;(); // ok</span><br></pre></td></tr></table></div></figure>

        <h4 id="2、运行时类型信息不适用于泛型"   >
          <a href="#2、运行时类型信息不适用于泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、运行时类型信息不适用于泛型" class="headerlink" title="2、运行时类型信息不适用于泛型"></a>2、运行时类型信息不适用于泛型</h4>
      这个也就是上面说的泛型擦除，泛型不支持运行时的信息(和反射有关)。</li>
</ul>
<p>instanceof后面是接口或类名，instanceof是运行时判断，也与泛型无关，所以，Java也不支持类似如下写法：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(p1 instanceof Pair&lt;Integer&gt;)</span><br></pre></td></tr></table></div></figure>

        <h4 id="3、Java-不能创建具体类型的泛型数组"   >
          <a href="#3、Java-不能创建具体类型的泛型数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、Java-不能创建具体类型的泛型数组" class="headerlink" title="3、Java 不能创建具体类型的泛型数组"></a>3、Java 不能创建具体类型的泛型数组</h4>
      <p>例如下面的list1和list2创建是错误的，但是后面的?可以，因为?代表的是未知类型:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GenericOther &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">//        List&lt;Integer&gt;[] list1 = new ArrayList&lt;Integer&gt;[]; // complier err</span><br><span class="line">//        List&lt;Boolean&gt; list2 = new ArrayList&lt;Boolean&gt;[]; // complier err</span><br><span class="line">        List&lt;?&gt;[] list3 = new ArrayList&lt;?&gt;[10]; // 这个却可以 ? 代表的是未知类型</span><br><span class="line">        list3[1] = new ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;?&gt; tmp = list3[1];</span><br><span class="line">        System.out.println(tmp.get(0));</span><br><span class="line">//        tmp.set(1, 2); complier err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>List&lt;Boolean&gt;</code> 和 <code>List&lt;Boolean&gt;</code> 在 Jvm 中等同于<code>List&lt;Object&gt;</code> ，所有的类型信息都被擦除，程序也无法分辨一个数组中的元素类型具体是 <code>List&lt;Integer&gt;</code>类型还是 <code>List&lt;Boolean&gt;</code> 类型。</li>
<li> <code>？</code> 代表未知类型，涉及的操作都基本上与类型无关，Jvm 不针对它对类型作判断，因此它能编译通过，但是，它只能读，不能写。比如，上面的 tmp 这个局部变量，它只能进行 get() 操作，不能进行 add() 操作。<br>再从如果可以创建泛型数组会出现什么样的问题来看: 数组可以进行不同类型之间的转换，但是也需要注意使用，使用不当就会造成运行时异常，而如果运行创建泛型数组也会产生类似的问题，所以Java干脆禁止。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class NoGenericClassArray &#123;</span><br><span class="line">     private static class Pair &#123; //　Generic Class</span><br><span class="line">        private Object first;</span><br><span class="line">        private Object second;</span><br><span class="line">        public Pair(Object first, Object second) &#123;</span><br><span class="line">            this.first = first;</span><br><span class="line">            this.second = second;</span><br><span class="line">        &#125;</span><br><span class="line">        public Object getFirst() &#123;</span><br><span class="line">            return first;</span><br><span class="line">        &#125;</span><br><span class="line">        public Object getSecond() &#123;</span><br><span class="line">            return second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 数组是Java直接支持的概念，它知道数组元素的实际类型，</span><br><span class="line">        // 它知道Object和Number都是Integer的父类型，所以这个操作是允许的。</span><br><span class="line">        Integer[] ints = new Integer[10];</span><br><span class="line">        Number[] numbers = ints; //  is ok</span><br><span class="line">        Object[] objs = ints;</span><br><span class="line"></span><br><span class="line">        // 虽然Java允许这种转换，但是如果使用不恰当，就有可能引起运行时异常</span><br><span class="line">        Integer[] ints2 = new Integer[10];</span><br><span class="line">        Object[] objs2 = ints2;</span><br><span class="line">        objs2[0] = &quot;hello&quot;; // RuntimeException</span><br><span class="line"></span><br><span class="line">//        Pair&lt;Object, Integer&gt;[] options = new Pair&lt;Object, Integer&gt;[3]; //如果可以，那最后一行就会不会编译错误，这样显然是不行的</span><br><span class="line">//        Object[] objs = options;</span><br><span class="line">//        objs[0] = new Pair&lt;Double, String&gt;(12.34, &quot;hello&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="4、不能通过类型参数创建对象"   >
          <a href="#4、不能通过类型参数创建对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#4、不能通过类型参数创建对象" class="headerlink" title="4、不能通过类型参数创建对象"></a>4、不能通过类型参数创建对象</h4>
      下面的写法是非法的。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T elm = new T();</span><br><span class="line">T[] arr = new T[10];</span><br></pre></td></tr></table></div></figure>
如果允许，本来你以为创建的就是对应类型的对象，但由于类型擦除，Java只能创建Object类型的对象，而无法创建T类型的对象。 那如果确实希望根据类型创建对象呢？需要设计API接受类型对象，即Class对象，并使用Java中的反射机制，如果类型有默认构造方法，可以调用Class的newInstance方法构建对象：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T create(Class&lt;T&gt; type)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return type.newInstance();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="5、泛型类类型参数不能用于静态变量和方法，泛型类中泛型只能用在成员变量上，只能使用引用类型，在接口中泛型只能只能用在抽象方法中，全局常量不能使用泛型"   >
          <a href="#5、泛型类类型参数不能用于静态变量和方法，泛型类中泛型只能用在成员变量上，只能使用引用类型，在接口中泛型只能只能用在抽象方法中，全局常量不能使用泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#5、泛型类类型参数不能用于静态变量和方法，泛型类中泛型只能用在成员变量上，只能使用引用类型，在接口中泛型只能只能用在抽象方法中，全局常量不能使用泛型" class="headerlink" title="5、泛型类类型参数不能用于静态变量和方法，泛型类中泛型只能用在成员变量上，只能使用引用类型，在接口中泛型只能只能用在抽象方法中，全局常量不能使用泛型"></a>5、泛型类类型参数不能用于静态变量和方法，泛型类中泛型只能用在成员变量上，只能使用引用类型，在接口中泛型只能只能用在抽象方法中，全局常量不能使用泛型</h4>
      对于泛型类声明的类型参数，可以在实例变量和方法中使用，但在静态变量和静态方法中是不能使用的。下面的写法是非法的:<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&lt;T&gt; &#123;</span><br><span class="line">    private static T instance;</span><br><span class="line">    public synchronized static T getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">             // 创建实例</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></div></figure>
如果合法的话，那么对于每种实例化类型，都需要有一个对应的静态变量和方法。但由于类型擦除，Singleton类型只有一份，静态变量和方法都是类型的属性，且与类型参数无关，所以不能使用泛型类类型参数。<br>但是，对于静态方法，它可以是泛型方法，可以声明自己的类型参数，这个参数与泛型类的类型参数是没有关系的。
        <h4 id="6、子类继承父类泛型"   >
          <a href="#6、子类继承父类泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#6、子类继承父类泛型" class="headerlink" title="6、子类继承父类泛型"></a>6、子类继承父类泛型</h4>
      注意子类继承泛型的注意事项: 可以有四种方式，可以按需实现，或者定义子类自己的泛型等<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class SubClass &#123;</span><br><span class="line"></span><br><span class="line">    public abstract class Father&lt;T1,T2&gt; &#123;     //注意实际过程中一般定义为抽象的父类</span><br><span class="line">        T1 age;</span><br><span class="line">        public abstract void test(T2 name);  //抽象方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1)全部保留</span><br><span class="line">    class C1&lt;T1,T2,A,B&gt; extends Father&lt;T1,T2&gt;&#123;  //除了继承父类,可以自己&quot;加&quot;&quot;富二代&quot;(不是负二代)</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void test(T2 name) &#123;</span><br><span class="line">            // this.age --&gt;  T1类型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2)部分保留</span><br><span class="line">    class C2&lt;T2,A,B&gt; extends Father&lt;Integer,T2&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void test(T2 name) &#123;</span><br><span class="line">            // this.age --&gt;  Integer类型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //不保留: --&gt;按需实现</span><br><span class="line">    class C3&lt;A,B&gt; extends Father&lt;Integer,String&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void test(String name) &#123; //注意这里是String 不是T2</span><br><span class="line">            // this.age --&gt;  Integer类型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2)没有类型 : 擦除 (类似于Object)//相当于</span><br><span class="line">    class C4&lt;A,B&gt; extends Father &#123;  //相当于  class C4&lt;A,B&gt; extends Father&lt;Object,Object&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void test(Object name) &#123; //注意这里是Object(完全没有类型(擦除))</span><br><span class="line">            // this.age --&gt;  Object类型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://hawawa.gitee.io">hao peng</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://hawawa.gitee.io/2022/05/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/">https://hawawa.gitee.io/2022/05/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://hawawa.gitee.io/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://hawawa.gitee.io/tags/Java/">Java</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/05/08/Filebeat%E5%AE%9E%E7%8E%B0ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Filebeat实现ELK日志收集</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/05/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/"><span class="paginator-prev__text">Java基础之反射</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">
          泛型概述以及泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">
          泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">
          三、泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81extends%E3%80%81-lt-%E3%80%81%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%BF%85%E9%A1%BB%E6%98%AF%E7%BB%99%E5%AE%9A%E7%9A%84%E6%88%96%E8%80%85%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">
          四、extends、&lt;&#x3D;、参数类型必须是给定的或者子类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%8A%E7%95%8C%E4%B8%BA%E6%9F%90%E4%B8%AA%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">
          1、上界为某个具体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8A%E7%95%8C%E4%B8%BA%E6%9F%90%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">
          2.上界为某个接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8A%E7%95%8C%E4%B8%BA%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">
          3.上界为其他参数类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">
          五、通配符?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9C%89%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">
          1、有限定类型通配符的简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%97%A0%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">
          2、无限定类型通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81super%E3%80%81-gt-%E3%80%81%E8%B6%85%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">
          六、super、&gt;&#x3D;、超类型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.</span> <span class="toc-text">
          1、使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%B2%A1%E6%9C%89-lt-T-super-E-gt-%E6%9C%89"><span class="toc-number">6.2.</span> <span class="toc-text">
          2、没有&lt; T super E&gt;(有)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6extends%E3%80%81super%E6%AF%94%E8%BE%83"><span class="toc-number">7.</span> <span class="toc-text">
          七、通配符extends、super比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B3%9B%E5%9E%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.</span> <span class="toc-text">
          九、泛型注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%88%96%E8%80%85%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E4%B8%8D%E6%8E%A5%E5%8F%97-8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">8.1.</span> <span class="toc-text">
          1、基本类型不能用于实例化类型参数，也就是泛型类或者泛型方法中，不接受 8 种基本数据类型。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.2.</span> <span class="toc-text">
          2、运行时类型信息不适用于泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Java-%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">8.3.</span> <span class="toc-text">
          3、Java 不能创建具体类型的泛型数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.4.</span> <span class="toc-text">
          4、不能通过类型参数创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD%E6%B3%9B%E5%9E%8B%E5%8F%AA%E8%83%BD%E7%94%A8%E5%9C%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8A%EF%BC%8C%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%B3%9B%E5%9E%8B%E5%8F%AA%E8%83%BD%E5%8F%AA%E8%83%BD%E7%94%A8%E5%9C%A8%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.5.</span> <span class="toc-text">
          5、泛型类类型参数不能用于静态变量和方法，泛型类中泛型只能用在成员变量上，只能使用引用类型，在接口中泛型只能只能用在抽象方法中，全局常量不能使用泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.6.</span> <span class="toc-text">
          6、子类继承父类泛型</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/avatar.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">路漫漫其修远兮，吾将上下而求索</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">59</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>hao peng</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>