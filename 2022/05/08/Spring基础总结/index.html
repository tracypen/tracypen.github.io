<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favor16.ico?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favor32.ico?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="Spring笔记整理">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring基础总结">
<meta property="og:url" content="https://hawawa.gitee.io/2022/05/08/Spring%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="peng.hao">
<meta property="og:description" content="Spring笔记整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873379da165a406994e17983bb5f4e59~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75306b0c6a224ee78f76389324630da7~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e3935f72dd4f67b05e0b847594f247~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2022-05-08T13:04:55.000Z">
<meta property="article:modified_time" content="2022-05-19T08:22:43.570Z">
<meta property="article:author" content="hao peng">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873379da165a406994e17983bb5f4e59~tplv-k3u1fbpfcp-watermark.image"><title>Spring基础总结 | peng.hao</title><link ref="canonical" href="https://hawawa.gitee.io/2022/05/08/Spring%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">peng.hao</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Spring基础总结</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-08</span></span></div></header><div class="post-body">
        <h1 id="Spring笔记整理"   >
          <a href="#Spring笔记整理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring笔记整理" class="headerlink" title="Spring笔记整理"></a>Spring笔记整理</h1>
      <span id="more"></span>


        <h2 id="1-Spring概述"   >
          <a href="#1-Spring概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Spring概述" class="headerlink" title="1. Spring概述"></a>1. Spring概述</h2>
      <p>Spring是一个轻量级的IoC和AOP容器框架，为Java应用程序提供基础性服务，简化了企业应用程序的开发，使得开发者只需要关心业务需求。</p>
<p>几个重要模块：</p>
<ul>
<li>Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务</li>
<li>Spring AOP：AOP服务</li>
<li>Spring ORM：对现有的ORM框架的支持</li>
<li>Spring Web : 为创建Web应用程序提供支持</li>
<li>Spring JDBC : Java数据库连接</li>
</ul>

        <h2 id="2-IOC"   >
          <a href="#2-IOC" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-IOC" class="headerlink" title="2. IOC"></a>2. IOC</h2>
      <p>IOC就是<strong>控制反转</strong>（Inverse of Control），是<strong>依赖倒置原则</strong>的一种代码设计思路，具体采用的方法就是<strong>依赖注入</strong>（Dependency Injection）。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873379da165a406994e17983bb5f4e59~tplv-k3u1fbpfcp-watermark.image" alt="beanSelf.jpg"></p>
<p><strong>依赖倒置原则</strong></p>
<p>把原本的高层依赖底层“倒置”过来，变成底层依赖高层。高层决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现“牵一发动全身”的情况。</p>
<p><strong>依赖注入</strong></p>
<p>把底层类作为参数传入上层类，实现上层类对下层类的“控制”。主要有三种方式：</p>
<ul>
<li>构造方法传递</li>
<li>Setter传递</li>
<li>接口传递</li>
</ul>
<p>这三种方式的核心思路都差不多，都是为了实现控制反转（依赖注入是方法，是为了实现控制反转）。</p>
<p><strong>控制反转容器</strong>（IoC Container）</p>
<p>对目标类进行初始化的一系列代码发生的地方，就是控制反转容器。他的优点主要是以下两点：</p>
<ul>
<li>降低重复代码</li>
</ul>
<p>因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一个类都要亲手去写那一大段初始化的代码。</p>
<ul>
<li>隐藏细节</li>
</ul>
<p>在创建实例的时候不需要了解其中的细节。我们自己手动创建一个instance时候，是从底层往上层new的，这个过程中，我们需要了解整个类构造函数是怎么定义的，才能一步一步new/注入。而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new。IoC Container可以直接隐藏具体的创建实例的细节，我们只需要告诉它我们需要什么实例，他就会把对应类实例初始化好，我们不用管这个实例是怎么一步一步被创建出来的。</p>
<p><strong>IOC实现原理</strong></p>
<p>工厂模式加反射机制，例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                    f = (Fruit) Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-AOP"   >
          <a href="#3-AOP" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-AOP" class="headerlink" title="3. AOP"></a>3. AOP</h2>
      <p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>

        <h4 id="代理模式"   >
          <a href="#代理模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4>
      <p>AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理的代表则为Spring AOP。</p>

        <h5 id="（1）静态代理"   >
          <a href="#（1）静态代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）静态代理" class="headerlink" title="（1）静态代理"></a>（1）静态代理</h5>
      <p>AspectJ是静态代理，也称为编译时增强，AOP框架会在编译阶段生成AOP代理类，并将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>

        <h5 id="（2）动态代理"   >
          <a href="#（2）动态代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）动态代理" class="headerlink" title="（2）动态代理"></a>（2）动态代理</h5>
      <p>Spring AOP使用的是动态代理，所谓的动态代理不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<ul>
<li>① JDK动态代理只提供接口的代理，不支持类的代理，要求被代理类实现接口。</li>
</ul>
<p>JDK动态代理的核心是InvocationHandler接口和Proxy类，在获取代理对象时，使用Proxy类来动态创建目标类的代理类（即最终真正的代理类，这个类继承自Proxy并实现了我们定义的接口），当代理对象调用真实对象的方法时， InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起。</p>
<ul>
<li>② 如果被代理类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</li>
</ul>
<p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>

        <h5 id="（3）动与静的区别"   >
          <a href="#（3）动与静的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）动与静的区别" class="headerlink" title="（3）动与静的区别"></a>（3）动与静的区别</h5>
      <ul>
<li>生成AOP代理对象的时机不同，一个是编译时增强，一个是运行时增强。</li>
<li>Spring AOP 基于代理，而 AspectJ 基于字节码操作</li>
<li>相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</li>
</ul>

        <h2 id="4-SpringBean生命周期"   >
          <a href="#4-SpringBean生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-SpringBean生命周期" class="headerlink" title="4.SpringBean生命周期"></a>4.SpringBean生命周期</h2>
      <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75306b0c6a224ee78f76389324630da7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

        <h3 id="一、实例化Bean"   >
          <a href="#一、实例化Bean" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、实例化Bean" class="headerlink" title="一、实例化Bean"></a>一、实例化Bean</h3>
      <ul>
<li>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。</li>
<li>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</li>
</ul>

        <h3 id="二、设置对象属性（依赖注入）"   >
          <a href="#二、设置对象属性（依赖注入）" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、设置对象属性（依赖注入）" class="headerlink" title="二、设置对象属性（依赖注入）"></a>二、设置对象属性（依赖注入）</h3>
      <p>实例化后的对象被封装在<code>BeanWrapper</code>对象中，紧接着，Spring根据<code>BeanDefinition</code>中的信息 以及 通过<code>BeanWrapper</code>提供的设置属性的接口完成属性设置与依赖注入。</p>

        <h3 id="三、处理Aware接口"   >
          <a href="#三、处理Aware接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、处理Aware接口" class="headerlink" title="三、处理Aware接口"></a>三、处理Aware接口</h3>
      <p>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源：</p>
<ul>
<li>如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，传入Bean的名字；</li>
<li>如果这个Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li>
<li>如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</li>
<li>如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</li>
</ul>

        <h3 id="四、BeanPostProcessor前置处理"   >
          <a href="#四、BeanPostProcessor前置处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、BeanPostProcessor前置处理" class="headerlink" title="四、BeanPostProcessor前置处理"></a>四、BeanPostProcessor前置处理</h3>
      <p>如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p>

        <h3 id="五、InitializingBean"   >
          <a href="#五、InitializingBean" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、InitializingBean" class="headerlink" title="五、InitializingBean"></a>五、InitializingBean</h3>
      <p>如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。</p>

        <h3 id="六、init-method"   >
          <a href="#六、init-method" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、init-method" class="headerlink" title="六、init-method"></a>六、init-method</h3>
      <p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p>

        <h3 id="七、BeanPostProcessor后置处理器"   >
          <a href="#七、BeanPostProcessor后置处理器" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、BeanPostProcessor后置处理器" class="headerlink" title="七、BeanPostProcessor后置处理器"></a>七、BeanPostProcessor后置处理器</h3>
      <p>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>
<blockquote>
<p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p>
</blockquote>

        <h3 id="八、DisposableBean"   >
          <a href="#八、DisposableBean" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、DisposableBean" class="headerlink" title="八、DisposableBean"></a>八、DisposableBean</h3>
      <p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p>

        <h3 id="九、destroy-method"   >
          <a href="#九、destroy-method" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、destroy-method" class="headerlink" title="九、destroy-method"></a>九、destroy-method</h3>
      <p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>

        <h2 id="5-Spring中用到的设计模式"   >
          <a href="#5-Spring中用到的设计模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Spring中用到的设计模式" class="headerlink" title="5.Spring中用到的设计模式"></a>5.Spring中用到的设计模式</h2>
      <ul>
<li>工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式 : Spring AOP 功能的实现。</li>
<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>
<li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li>
</ul>

        <h2 id="6-Spring中bean的作用域"   >
          <a href="#6-Spring中bean的作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Spring中bean的作用域" class="headerlink" title="6.Spring中bean的作用域"></a>6.Spring中bean的作用域</h2>
      <p>（1）singleton：默认作用域，单例bean，每个容器中只有一个bean的实例。</p>
<p>（2）prototype：为每一个bean请求创建一个实例。</p>
<p>（3）request：为每一个request请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p>
<p>（4）session：与request范围类似，同一个session会话共享一个实例，不同会话使用不同的实例。</p>
<p>（5）global-session：全局作用域，所有会话共享一个实例。如果想要声明让所有会话共享的存储变量的话，那么这全局变量需要存储在global-session中。</p>

        <h2 id="7-Spring框架中的Bean是线程安全的么？"   >
          <a href="#7-Spring框架中的Bean是线程安全的么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-Spring框架中的Bean是线程安全的么？" class="headerlink" title="7.Spring框架中的Bean是线程安全的么？"></a>7.Spring框架中的Bean是线程安全的么？</h2>
      <p>Spring容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体情况还是要结合Bean的作用域来讨论。</p>
<p>（1）对于prototype作用域的Bean，每次都创建一个新对象，也就是线程之间不存在Bean共享，因此不会有线程安全问题。</p>
<p>（2）对于singleton作用域的Bean，所有的线程都共享一个单例实例的Bean，因此是存在线程安全问题的。但是如果单例Bean是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Controller类、Service类和Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<ul>
<li>有状态Bean(Stateful Bean) ：就是有实例变量的对象，可以保存数据，是非线程安全的。</li>
<li>无状态Bean(Stateless Bean)：就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。</li>
</ul>
<p>对于有状态的bean（比如Model和View），就需要自行保证线程安全，最浅显的解决办法就是将有状态的bean的作用域由“singleton”改为“prototype”。</p>
<p>也可以采用ThreadLocal解决线程安全问题，为每个线程提供一个独立的变量副本，不同线程只操作自己线程的副本变量。</p>

        <h2 id="8-Spring如何解决循环依赖问题"   >
          <a href="#8-Spring如何解决循环依赖问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-Spring如何解决循环依赖问题" class="headerlink" title="8. Spring如何解决循环依赖问题"></a>8. Spring如何解决循环依赖问题</h2>
      <p>循环依赖问题在Spring中主要有三种情况：</p>
<p>（1）通过构造方法进行依赖注入时产生的循环依赖问题。</p>
<p>（2）通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</p>
<p>（3）通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。 在Spring中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：</p>
<ul>
<li>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</li>
<li>第二种setter方法（多例）的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。</li>
</ul>

        <h4 id="三级缓存"   >
          <a href="#三级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4>
      <ul>
<li>第一级缓存〈也叫单例池）singletonObjects:存放已经经历了完整生命周期的Bean对象</li>
<li>第二级缓存: earlySingletonObjects，存放早期暴露出来的Bean对象，Bean的生命周期未结束（属性还未填充完整）</li>
<li>第三级缓存: Map&lt;String, ObiectFactory&lt;?&gt;&gt; singletonFactories，存放可以生成Bean的工厂</li>
</ul>

        <h4 id="解决循环依赖的过程："   >
          <a href="#解决循环依赖的过程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决循环依赖的过程：" class="headerlink" title="解决循环依赖的过程："></a>解决循环依赖的过程：</h4>
      <ul>
<li>A创建过程中需要B，于是A将自己放到三级缓存里面，去实例化B</li>
<li>B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A</li>
<li>B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态），然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面。</li>
</ul>

        <h2 id="9-Spring事务"   >
          <a href="#9-Spring事务" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-Spring事务" class="headerlink" title="9. Spring事务"></a>9. Spring事务</h2>
      <p>Spring事务的本质其实就是数据库对事务的支持。Spring只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过binlog或者undo log实现的。Spring会在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。</p>

        <h4 id="（1）Spring事务的种类："   >
          <a href="#（1）Spring事务的种类：" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）Spring事务的种类：" class="headerlink" title="（1）Spring事务的种类："></a>（1）Spring事务的种类：</h4>
      <p>spring支持编程式事务管理和声明式事务管理两种方式：</p>
<ul>
<li>编程式事务管理</li>
</ul>
<p>使用TransactionTemplate，在代码中硬编码(不推荐使用)</p>
<ul>
<li>声明式事务管理</li>
</ul>
<p>是建立在AOP之上的，其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<p>声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>

        <h4 id="（2）spring的事务传播机制"   >
          <a href="#（2）spring的事务传播机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）spring的事务传播机制" class="headerlink" title="（2）spring的事务传播机制"></a>（2）spring的事务传播机制</h4>
      <p>Spring事务的传播机制说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。事务传播机制实际上是使用简单的ThreadLocal实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p>
<ul>
<li>① PROPAGATION_REQUIRED：（默认传播行为）如果当前没有事务，就创建一个新事务；如果当前存在事务，就加入该事务。</li>
<li>② PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。</li>
<li>③ PROPAGATION_SUPPORTS：如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。‘</li>
<li>④ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>⑤ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。</li>
<li>⑥ PROPAGATION_MANDATORY：如果当前存在事务，就加入该事务；如果当前不存在事务，就抛出异常。</li>
<li>⑦ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>

        <h4 id="（3）Spring中的隔离级别"   >
          <a href="#（3）Spring中的隔离级别" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）Spring中的隔离级别" class="headerlink" title="（3）Spring中的隔离级别"></a>（3）Spring中的隔离级别</h4>
      <ul>
<li>① ISOLATION_DEFAULT：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</li>
<li>② ISOLATION_READ_UNCOMMITTED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据。</li>
<li>③ ISOLATION_READ_COMMITTED：读已提交，允许事务在执行过程中，读取其他事务已经提交的数据。</li>
<li>④ ISOLATION_REPEATABLE_READ：可重复读，在同一个事务内，任意时刻的查询结果都是一致的。</li>
<li>⑤ ISOLATION_SERIALIZABLE：所有事务逐个依次执行。</li>
</ul>

        <h2 id="10-Spring框架中有哪些不同类型的事件"   >
          <a href="#10-Spring框架中有哪些不同类型的事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-Spring框架中有哪些不同类型的事件" class="headerlink" title="10. Spring框架中有哪些不同类型的事件"></a>10. Spring框架中有哪些不同类型的事件</h2>
      <p>Spring 提供了以下5种标准的事件：</p>
<p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p>
<p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p>
<p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p>
<p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p>
<p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p>
<p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p>

        <h2 id="11-BeanFactory和ApplicationContext有什么区别？"   >
          <a href="#11-BeanFactory和ApplicationContext有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#11-BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="11. BeanFactory和ApplicationContext有什么区别？"></a>11. BeanFactory和ApplicationContext有什么区别？</h2>
      <p>BeanFactory和ApplicationContext是Spring的两大核心接口，都是Spring的IoC容器。</p>
<p>（1）BeanFactory是Spring里面最底层的接口，是IoC的核心，定义了IoC的基本功能，包含了各种Bean的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能，如国际化（简单来说就是不同国家/地区/语言的用户，访问同一个程序，得到对应的本地化资源）和资源文件访问等。</p>
<p>（2）加载形式</p>
<ul>
<li>BeanFactroy采用的是延迟加载形式来注入Bean的，只有在使用到某个Bean时(调用<code>getBean()</code>)，才对该Bean进行加载实例化。</li>
<li>ApplicationContext在容器启动时，一次性创建了所有的Bean。</li>
<li>ApplicationContext启动后预载入所有的单实例Bean，所以在运行的时候速度比较快。</li>
<li>ApplicationContext 唯一的不足是占用内存空间，当应用程序配置Bean较多时，程序启动较慢。</li>
</ul>
<p>（3）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<p>（4）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>

        <h2 id="12-Spring的自动装配"   >
          <a href="#12-Spring的自动装配" class="heading-link"><i class="fas fa-link"></i></a><a href="#12-Spring的自动装配" class="headerlink" title="12. Spring的自动装配"></a>12. Spring的自动装配</h2>
      <p>Spring 容器能够自动装配 bean。也就是说，可以通过检查BeanFactory的内容让Spring自动解析bean的协作者。 自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li>byName - 它根据 bean的名称注入对象依赖项。它匹配并装配其属性与 XML文件中由相同名称定义的 bean。</li>
<li>byType - 它根据类型注入对象依赖项。如果属性的类型与XML文件中的一个bean名称匹配，则匹配并装配属性。</li>
<li>构造函数- 它通过调用类的构造函数来注入依赖项。它有大量的参数。autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配</li>
</ul>

        <h2 id="13-Spring-AOP里面的几个名词的概念"   >
          <a href="#13-Spring-AOP里面的几个名词的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#13-Spring-AOP里面的几个名词的概念" class="headerlink" title="13. Spring AOP里面的几个名词的概念"></a>13. Spring AOP里面的几个名词的概念</h2>
      <p>（1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。 </p>
<p>（2）切面（Aspect）：被抽取出来的公共模块，可以用来会横切多个对象。Aspect切面可以看成 Pointcut切点 和 Advice通知 的结合，一个切面可以由多个切点和通知组成。</p>
<p>在Spring AOP中，切面可以在类上使用 @AspectJ 注解来实现。</p>
<p>（3）切点（Pointcut）：切点用于定义 要对哪些Join point进行拦截。</p>
<p>切点分为execution方式和annotation方式。execution方式可以用路径表达式指定对哪些方法拦截，比如指定拦截add<em>、search</em>。annotation方式可以指定被哪些注解修饰的代码进行拦截。</p>
<p>（4）通知（Advice）：指要在连接点（Join Point）上执行的动作，即增强的逻辑，比如权限校验和、日志记录等。通知有各种类型，包括Around、Before、After、After returning、After throwing。</p>
<p>（5）目标对象（Target）：包含连接点的对象，也称作被通知（Advice）的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。</p>
<p>（6）织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程。</p>
<p>（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p>
<p>几个概念的关系图可以参考下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e3935f72dd4f67b05e0b847594f247~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

        <h2 id="14-Spring通知（Advice）有哪些类型？"   >
          <a href="#14-Spring通知（Advice）有哪些类型？" class="heading-link"><i class="fas fa-link"></i></a><a href="#14-Spring通知（Advice）有哪些类型？" class="headerlink" title="14. Spring通知（Advice）有哪些类型？"></a>14. Spring通知（Advice）有哪些类型？</h2>
      <p>（1）前置通知（Before Advice）：在连接点（Join point）之前执行的通知。</p>
<p>（2）后置通知（After Advice）：当连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 </p>
<p>（3）环绕通知（Around Advice）：包围一个连接点的通知，这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</p>
<p>（4）返回后通知（AfterReturning Advice）：在连接点正常完成后执行的通知（如果连接点抛出异常，则不执行）</p>
<p>（5）抛出异常后通知（AfterThrowing advice）：在方法抛出异常退出时执行的通知</p>
<p><strong>通知顺序</strong></p>
<ul>
<li>Spring4（默认用的是JDK的动态代理）</li>
</ul>
<p>正常：环绕通知前-&gt;前置通知-&gt;方法正常运行-&gt;环绕通知后-&gt;后置通知-&gt;返回后通知</p>
<p>异常：环绕通知前-&gt;前置通知-&gt;方法运行异常-&gt;后置通知-&gt;异常通知</p>
<ul>
<li>Spring5（默认动态代理用的是cglib）</li>
</ul>
<p>正常：环绕通知前-&gt;前置通知-&gt;方法正常运行-&gt;返回后通知-&gt;后置通知-&gt;环绕通知后</p>
<p>异常：环绕通知前-&gt;前置通知-&gt;方法运行异常-&gt;异常通知-&gt;后置通知</p>

        <h2 id="15-BeanFactory与FactoryBean的区别"   >
          <a href="#15-BeanFactory与FactoryBean的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#15-BeanFactory与FactoryBean的区别" class="headerlink" title="15. BeanFactory与FactoryBean的区别"></a>15. BeanFactory与FactoryBean的区别</h2>
      <p>他们两个都是个工厂，但FactoryBean本质上还是一个Bean，也归BeanFactory管理；BeanFactory是Spring容器的顶层接口，FactoryBean更类似于用户自定义的工厂接口。</p>

        <h4 id="BeanFactory"   >
          <a href="#BeanFactory" class="heading-link"><i class="fas fa-link"></i></a><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4>
      <p>BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>
<ul>
<li>DefaultListableBeanFactory</li>
<li>XmlBeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>这些实现类又从不同的维度分别有不同的扩展。</p>
<p>使用场景：</p>
<ul>
<li>从Ioc容器中获取Bean(byName or byType)</li>
<li>检索Ioc容器中是否包含指定的Bean</li>
<li>判断Bean是否为单例</li>
</ul>

        <h4 id="FactoryBean"   >
          <a href="#FactoryBean" class="heading-link"><i class="fas fa-link"></i></a><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4>
      <p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<p>使用场景：</p>
<p>FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。 我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。 所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。</p>

        <h2 id="16-Spring容器的启动流程"   >
          <a href="#16-Spring容器的启动流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#16-Spring容器的启动流程" class="headerlink" title="16. Spring容器的启动流程"></a>16. Spring容器的启动流程</h2>
      <p>（1）初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中</p>
<ul>
<li>实例化BeanFactory【DefaultListableBeanFactory】工厂，用于生成Bean对象</li>
<li>实例化BeanDefinitionReader注解配置读取器，用于对特定注解（如@Service、@Repository）的类进行读取转化成 BeanDefinition 对象，（BeanDefinition 是 Spring 中极其重要的一个概念，它存储了 bean 对象的所有特征信息，如是否单例，是否懒加载，factoryBeanName 等）</li>
<li>实例化ClassPathBeanDefinitionScanner路径扫描器，用于对指定的包目录进行扫描查找 bean 对象</li>
</ul>
<p>（2）将配置类的BeanDefinition注册到容器中：</p>
<p>（3）调用refresh()方法刷新容器</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://hawawa.gitee.io">hao peng</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://hawawa.gitee.io/2022/05/08/Spring%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">https://hawawa.gitee.io/2022/05/08/Spring%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://hawawa.gitee.io/tags/Spring/">Spring</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/05/08/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Spring源码学习环境搭建</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/05/08/Mybatis%E9%9B%86%E6%88%90Spring%E5%8E%9F%E7%90%86/"><span class="paginator-prev__text">Mybatis集成Spring原理</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">
          Spring笔记整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spring%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">
          1. Spring概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IOC"><span class="toc-number">1.2.</span> <span class="toc-text">
          2. IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AOP"><span class="toc-number">1.3.</span> <span class="toc-text">
          3. AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">
          代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.0.1.1.</span> <span class="toc-text">
          （1）静态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.0.1.2.</span> <span class="toc-text">
          （2）动态代理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E4%B8%8E%E9%9D%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.0.1.3.</span> <span class="toc-text">
          （3）动与静的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.</span> <span class="toc-text">
          4.SpringBean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96Bean"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          一、实例化Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%EF%BC%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          二、设置对象属性（依赖注入）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%84%E7%90%86Aware%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          三、处理Aware接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81BeanPostProcessor%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">
          四、BeanPostProcessor前置处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81InitializingBean"><span class="toc-number">1.4.5.</span> <span class="toc-text">
          五、InitializingBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81init-method"><span class="toc-number">1.4.6.</span> <span class="toc-text">
          六、init-method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81BeanPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">
          七、BeanPostProcessor后置处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81DisposableBean"><span class="toc-number">1.4.8.</span> <span class="toc-text">
          八、DisposableBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81destroy-method"><span class="toc-number">1.4.9.</span> <span class="toc-text">
          九、destroy-method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spring%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">
          5.Spring中用到的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Spring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.6.</span> <span class="toc-text">
          6.Spring中bean的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84Bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">
          7.Spring框架中的Bean是线程安全的么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">
          8. Spring如何解决循环依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">
          三级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">
          解决循环依赖的过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.9.</span> <span class="toc-text">
          9. Spring事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">
          （1）Spring事务的种类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">
          （2）spring的事务传播机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Spring%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.9.0.3.</span> <span class="toc-text">
          （3）Spring中的隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">
          10. Spring框架中有哪些不同类型的事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">
          11. BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Spring%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">1.12.</span> <span class="toc-text">
          12. Spring的自动装配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Spring-AOP%E9%87%8C%E9%9D%A2%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.13.</span> <span class="toc-text">
          13. Spring AOP里面的几个名词的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Spring%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">
          14. Spring通知（Advice）有哪些类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-BeanFactory%E4%B8%8EFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">
          15. BeanFactory与FactoryBean的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory"><span class="toc-number">1.15.0.1.</span> <span class="toc-text">
          BeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FactoryBean"><span class="toc-number">1.15.0.2.</span> <span class="toc-text">
          FactoryBean</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.16.</span> <span class="toc-text">
          16. Spring容器的启动流程</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/avatar.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">路漫漫其修远兮，吾将上下而求索</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">59</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">33</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>hao peng</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>